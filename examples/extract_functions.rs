use std::env;
use std::fs;
use std::io::Write;
use std::path::{Path, PathBuf};

/// Extract functions from Python files for compilation
///
/// This example extracts all function definitions from Python files
/// and creates a new Python file that only contains the functions,
/// suitable for compilation by Waspy.
fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Parse command-line arguments
    let args: Vec<String> = env::args().collect();

    if args.len() < 2 {
        eprintln!("Usage: {} <project_directory> [output_file.py]", args[0]);
        eprintln!("Example: {} ../sot extracted_functions.py", args[0]);
        return Ok(());
    }

    let project_dir = Path::new(&args[1]);
    let output_file = if args.len() >= 3 {
        Path::new(&args[2]).to_path_buf()
    } else {
        Path::new("extracted_functions.py").to_path_buf()
    };

    if !project_dir.exists() || !project_dir.is_dir() {
        eprintln!(
            "Error: The project directory '{}' does not exist or is not a directory",
            project_dir.display()
        );
        return Ok(());
    }

    println!(
        "Extracting functions from Python files in '{}'",
        project_dir.display()
    );

    // Find all Python files
    let python_files = find_python_files(project_dir)?;
    println!("Found {} Python files", python_files.len());

    // Extract functions from all files
    let mut all_functions = Vec::new();
    let mut function_count = 0;

    for file_path in &python_files {
        let content = fs::read_to_string(file_path)?;
        let functions = extract_functions_from_file(&content);

        if !functions.is_empty() {
            let rel_path = file_path
                .strip_prefix(project_dir)
                .unwrap_or(file_path)
                .to_string_lossy();

            println!(
                "  Extracted {} functions from {}",
                functions.len(),
                rel_path
            );
            function_count += functions.len();

            // Add a header comment with the source file name
            all_functions.push(format!("\n# Functions from {}", rel_path));
            all_functions.extend(functions);
        }
    }

    if all_functions.is_empty() {
        println!("No functions found in any Python file!");
        return Ok(());
    }

    // Create the output file with all functions
    let output = all_functions.join("\n\n");

    // Add a header
    let header = format!(
        "# Extracted functions from {} Python files in {}\n\
         # Total functions: {}\n\
         # Generated by Waspy extract_functions.rs\n\n",
        python_files.len(),
        project_dir.display(),
        function_count
    );

    // Write to output file
    let mut file = fs::File::create(&output_file)?;
    file.write_all(header.as_bytes())?;
    file.write_all(output.as_bytes())?;

    println!(
        "Successfully extracted {} functions to {}",
        function_count,
        output_file.display()
    );
    println!("\nYou can now compile this file with:");
    println!(
        "cargo run --example advanced_compiler {}",
        output_file.display()
    );

    Ok(())
}

/// Find all Python files in a directory recursively
fn find_python_files(dir: &Path) -> Result<Vec<PathBuf>, Box<dyn std::error::Error>> {
    let mut python_files = Vec::new();

    // Skip these directories
    let skip_dirs = vec![
        "__pycache__",
        "venv",
        "env",
        ".venv",
        ".env",
        ".git",
        "node_modules",
        "site-packages",
        "dist",
        "build",
    ];

    for entry in fs::read_dir(dir)? {
        let entry = entry?;
        let path = entry.path();

        if path.is_dir() {
            // Skip directories that shouldn't be included
            if let Some(dir_name) = path.file_name() {
                let dir_name = dir_name.to_string_lossy();
                if skip_dirs.iter().any(|d| dir_name == *d) || dir_name.starts_with('.') {
                    continue;
                }
            }

            // Recursively scan subdirectory
            let mut sub_files = find_python_files(&path)?;
            python_files.append(&mut sub_files);
        } else if path.is_file() && path.extension().map_or(false, |ext| ext == "py") {
            python_files.push(path);
        }
    }

    Ok(python_files)
}

/// Extract function definitions from a Python file
fn extract_functions_from_file(content: &str) -> Vec<String> {
    let mut functions = Vec::new();
    let mut current_function = Vec::new();
    let mut in_function = false;
    let mut indentation = 0;

    for line in content.lines() {
        if !in_function {
            // Look for function definition
            if line.trim().starts_with("def ") {
                in_function = true;
                indentation = line.len() - line.trim_start().len();
                current_function.push(line.to_string());
            }
        } else {
            // Inside a function
            if line.is_empty() {
                current_function.push(line.to_string());
            } else {
                let line_indent = line.len() - line.trim_start().len();

                if line_indent <= indentation && !line.trim().is_empty() {
                    // End of function
                    functions.push(current_function.join("\n"));
                    current_function.clear();
                    in_function = false;

                    // Check if this line is the start of another function
                    if line.trim().starts_with("def ") {
                        in_function = true;
                        indentation = line.len() - line.trim_start().len();
                        current_function.push(line.to_string());
                    }
                } else {
                    // Continue the current function
                    current_function.push(line.to_string());
                }
            }
        }
    }

    // Don't forget the last function if we're still in one
    if in_function && !current_function.is_empty() {
        functions.push(current_function.join("\n"));
    }

    functions
}
